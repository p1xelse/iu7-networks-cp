\section{Аналитическая часть}

В данном разделе будут описаны основные теоретические аспекты, необходимые для решения поставленной задачи

\subsection{Протокол HTTP}

HTTP (англ. Hypertext Transfer Protocol, гипертекстовый транспортный
протокол) -- протокол, определяющий набор соглашений по передаче гипертекста (т.е. связанных веб-документов) между двумя компьютерами. HTTP
является текстовым протоколом без сохранения состояния. \ref{http}

Данный протокол задаёт следующие правила взаимодействия клиента и
сервера. 

\begin{itemize}[leftmargin=1.6\parindent]
	\item[--] HTTP-запросы производятся исключительно от клиентов к серверу, который способен только отвечать на запросы.
	\item[--] При запросе файла по HTTP клиент должен сформировать файловый
	URL (Uniform Resource Locator, единообразный указатель местонахождения ресурса).
	\item[--] Веб-сервер должен ответить на каждый HTTP-запрос, даже в случае возникновения ошибки.
\end{itemize}

HTTP-запросы и ответы имеют схожую структуру и состоят из следующих элементов. 
\begin{itemize}[leftmargin=1.6\parindent]
	\item[--] Стартовая строка, содержащая метод HTTP-запроса, цель запроса, версия протокола.
	\item[--] Необязательный набор заголовков HTTP, определяющий запрос или описывающий тело сообщения.
	\item[--] Необязательное тело сообщения, содержащее данные, связанные с запросом (например, содержимое HTML-формы), или документ, связанный с ответом. Наличие тела и его размер задаются начальной строкой и заголовками HTTP.
\end{itemize}

\newpage
Начальная строка и HTTP-заголовки HTTP-сообщения вместе называются заголовком, а его полезная нагрузка -- телом.
На рисунке \ref{fig:http_ex} представлен пример HTTP запроса и ответа версии 1.x.

\begin{figure}[hbtp]
	\centering
	\includegraphics[width=\textwidth]{img/http.png}
	\caption{Пример запроса и ответа HTTP.}
	\label{fig:http_ex}
\end{figure}

\subsection{Веб-серверы}

Веб-серверы, как правило, работают по протоколам HTTP/HTTPS и
предоставляют клиентам доступ к файлам, таким как веб-страницы. Чтобы загрузить веб-страницу, браузер отправляет запрос к веб-серверу, который выполняет поиск запрашиваемого файла в своём хранилище. Найдя файл, сервер считывает его, обрабатывает при необходимости и отсылает в браузер. 

Такие серверы могут работать со статическим и динамическим контентом:
статический отдаётся клиенту в исходном виде без изменений, а динамический
является результатом обработки данных на стороне сервера-приложения. Со статическим
контентом проще работать, в то время, как динамический контент обеспечивает
большую гибкость. 

Веб-серверы могут являтся  связующим звеном между клиентами, например браузерами, и серверами-приложенями, проксируя трафик.

\subsection{Cокеты}
\textbf{Сокет} — это абстракция конечной точки соединения, которая используется для обеспечения обмена данными между устройствами сети. Сокеты являются ключевым компонентом для установки и управления сетевыми соединениями.

Сокеты предоставляют интерфейс для создания конечных точек соединения в сети с использованием протоколов передачи данных, таких как TCP или
UDP. При разработке веб-серверов сокеты используются для «прослушивания»
входящих соединений от клиентов и передачи данных между сервером и клиентами.

Процесс создания сервера с использованием сокетов включает в себя следующие шаги.

\begin{itemize}[leftmargin=1.6\parindent]
	\item[1.] Создание сокета, который будет слушать входящие соединения.
	\item[2.] Привязка сокета к адресу и порту: после создания сокета необходимо привязать его к сетевому адресу и порту, на котором будет прослушиваться входящий трафик.
	\item[3.] Установка сервера в состояние прослушивания входящих соединений.
	\item[4.] Принятие входящего соединения.
	\item[5.] Обработка запросов и передача данных. После установки соединения с клиентом сервер может принимать запросы от клиента с помощью функций чтения и записи данных через сокет.
\end{itemize}

Использование сокетов в разработке серверов позволяет эффективно управлять сетевыми соединениями и обеспечивать передачу статического контента клиентам по сети.

\subsection{Мультиплексирование ввода-вывода}
Мультиплексирование ввода-вывода является методом обработки
нескольких операций ввода-вывода в одном потоке выполнения программы,
что позволяет повысить эффективность управления множеством соединений в
сетевых приложениях или приложениях с асинхронным вводом-выводом. Это
позволяет уменьшить задержки и повысить производительность.

Мультиплексоры позволяют приложению ожидать ввода или вывода данных из нескольких источников, таких как сокеты, файлы или сетевые устройства, используя один системный вызов вместо создания или управления каждым потоком или процессом отдельно.

Использование мультиплексирования ввода-вывода требует более сложной логики обработки событий, чем простое параллельное программирование, но оно может обеспечить более эффективное использование системных ресурсов и более высокую производительность.

Существуют следующие механизмы мультиплексирования сетевых соединений.

\textbf{select}

Это системный вызов, используемый в различных операционных
системах для ожидания событий на нескольких файловых дескрипторах,
таких как сокеты. Он позволяет одному потоку контролировать несколько соединений одновременно. Данный мультиплексор имеет ограничение на максимальное количество отслеживаемых файловых дескрипторов —
1024.

\textbf{pselect}

pselect схож по принципу работы с select и имеет те же ограничения, однако реализует более продвинутую обработку сигналов. В отличие от select, pselect позволяет процессу заблокироваться на ожидании событий ввода-вывода и одновременно игнорировать определенные сигналы или обрабатывать их в специфическим способом.

\textbf{epoll}

Cистемный вызов, предоставляемый в ядре Linux, обеспечивает более гибкие варианты работы с событиями ввода-вывода за счёт реализации модели уведомлений. В отличие от select и pselect, epoll предоставляет более эффективный способ мониторинга множества файловых дескрипторов на предмет готовности к вводу или выводу и не имеет ограничений на обработку файловых дескрипторов

epoll является наиболее современным и эффективным механизмом в сравнении с select и pselect и часто используется в высоконагруженных сетевых приложениях на ОС Linux.

\subsection{Распараллеливание обработки входящих запросов}
Для ускорения обработки запросов веб-серверы реализуют их параллельную обработку в многопроцессорной среде. Существует множество подходов к параллелизации работы веб-серверов, в данной работе будут рассмтрены: пул потоков (thread pool), разветвление (prefork) и (thread per request).

\textbf{Thread Pool} представляет собой набор потоков, готовых к выполнению
задач. Когда в систему поступает новая задача, она помещается в очередь, и
один из доступных потоков в пуле забирает эту задачу на выполнение. После
завершения задачи поток возвращается обратно в пул и становится доступным
для выполнения новых задач. Это способствует уменьшению накладных расходов на создание и уничтожение потоков, а также позволяет управлять ресурсами более эффективно и обеспечивает параллельное выполнение задач.

\textbf{Prefork} -- это модель параллелизации, при которой веб-сервер создаёт
отдельные процессы для обработки запросов. Такой подход позволяет изолировать обработку каждого запроса и повышает надежность веб-сервера, так как
сбои в одном процессе не влияют на остальные. Однако создание процессов
требует больше дополнительных ресурсов, чем использование пула потоков.


\textbf{Thread per request} -- эта модель обрабатывает каждый запрос от клиента в отдельном потоке управления. Это менее эффективно для запросов небольшой продолжительности из-за затрат на создание нового потока для каждого запроса. Он также может потреблять большое количество ресурсов ОС, если множество клиентов одновременно отправляют запросы.

Выбор между подходами зависит от конкретных требований веб-сервера, предполагаемой нагрузки и характера обрабатываемых запросов.



